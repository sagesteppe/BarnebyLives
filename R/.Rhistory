arrange(family, genus, species) %>%
unite('taxon_name_author', genus:infraspecific_author, remove = FALSE, na.rm = TRUE, sep = ' ') |>
mutate(taxon_name_author = str_trim(taxon_name_author, side = 'both'),
across(.cols  = infraspecific_rank:infraspecific_author, ~ na_if(.x, ' ')))
TaxUnpack <- function(path, continents, regions){
distributions <- read.table(unz(file.path(path, 'wcvp.zip'), 'wcvp_distribution.csv'),
sep = "|", header = TRUE, quote = "", fill = TRUE, encoding = "UTF-8")
distributions <- distributions[distributions$continent %in% continents
& distributions$region %in% regions, c('plant_name_id')]
distributions <- unique(distributions)
cat(crayon::green(length(distributions),
'accepted names found in this spatial domain.\nSit tight while we process all of the synonyms associated with them.'))
names <- read.table(unz(file.path(path, 'wcvp.zip'), 'wcvp_names.csv'),
sep = "|", header = TRUE, quote = "", fill = TRUE, encoding = "UTF-8")
names <- names[names$accepted_plant_name_id %in% distributions,
c('plant_name_id', 'taxon_rank', 'family', 'genus', 'species', 'infraspecific_rank',
'infraspecies', 'taxon_name', 'accepted_plant_name_id', 'parent_plant_name_id',
'taxon_status', 'taxon_authors')]
names <- names[names$taxon_rank %in% c('Species', 'Subspecies', 'Variety'),]
names <- dplyr::arrange(names, family, genus, species)
return(names)
}
reggs <- c('Northwestern U.S.A.', 'Southwestern U.S.A.',
'North-Central U.S.A.', 'South-Central U.S.A.')
oupu <- TaxUnpack(path = '/home/sagesteppe/Downloads',
continent = 'NORTHERN AMERICA', regions = reggs)
acc <- filter(oupu, taxon_status == 'Accepted')
species <- filter(acc, taxon_rank == 'Species') %>%
rename(specific_author = taxon_authors)
infra <- filter(acc, taxon_rank %in% c('Variety', 'Subspecies')) %>%
rename(infraspecific_author = taxon_authors)
bases <- filter(species, plant_name_id %in% infra$parent_plant_name_id) %>%
select(plant_name_id, specific_author)
species <- left_join(infra, bases, by = c('parent_plant_name_id' = 'plant_name_id')) %>%
relocate('specific_author', .after = species) %>%
relocate('infraspecific_author', .after = infraspecies) %>%
bind_rows(., species) |>
arrange(family, genus, species) %>%
unite('taxon_name_author', genus:infraspecific_author, remove = FALSE, na.rm = TRUE, sep = ' ') |>
mutate(taxon_name_author = str_trim(taxon_name_author, side = 'both'),
across(.cols  = infraspecific_rank:infraspecific_author, ~ na_if(.x, ' ')))
View(species)
data <- read.csv('data/test_data.csv', na.strings = "") %>%
drop_na(c('Longitude', 'Latitude', 'Date_digital')) %>%
unite(col = 'Scientific_name', c(Binomial, Infrarank, Infraspecies), na.rm=TRUE, sep = " ", remove = F)
library(tidyverse) # data operations
library(BarnebyLives) # for helping accession collections
data <- read.csv('data/test_data.csv', na.strings = "") %>%
drop_na(c('Longitude', 'Latitude', 'Date_digital')) %>%
unite(col = 'Scientific_name', c(Binomial, Infrarank, Infraspecies), na.rm=TRUE, sep = " ", remove = F)
View(data)
# devtools::install_github('sagesteppe/BarnebyLives')
library(tidyverse)
# devtools::install_github('sagesteppe/BarnebyLives')
library(tidyverse)
library(BarnebyLives)
library(googlesheets4)
library(textclean)
ca <- read_sheet('1iOQBNeGqRJ3yhA-Sujas3xZ2Aw5rFkktUKv3N_e4o8M',
sheet = 'Data Entry California - 2024') %>%
mutate(UNIQUEID = paste0(Primary_Collector, Collection_number)) %>%
data.frame()
data <- bind_rows(ca)
data <- dms2dd(data)
View(data)
#' @returns dataframe(/tibble) with coordinates unambiguously labeled as being in both degress, minutes, seconds (_dms) and decimal degrees (_dd).
#' @examples
#'  coords <- data.frame(
#'   longitude_dd = runif(15, min = -120, max = -100),
#'   latitude_dd = runif(15, min = 35, max = 48)
#' )
#' coords_formatted <- dms2dd( coords )
#' head(coords_formatted)
#' colnames(coords_formatted)
#' @export
dms2dd <- function(x, lat, long, dms){
# identify columns if they were not supplied
if(missing(lat)){
lat = colnames(x)[grep('lat', colnames(x), ignore.case = T)] }
if(missing(long)){
long = colnames(x)[grep('long', colnames(x), ignore.case = T)] }
# remove any N | E | S | W, or for that matter other alphabetical characters
x[,long] <- gsub('[[:alpha:]]|\\s', "", x[,long])
x[,lat] <- gsub('[[:alpha:]]|\\s', "", x[,lat])
# we will need to perform this operation across every single row,
# because some people will put dms and dd in the same column...
x_spl <- split(x, f = 1:nrow(x))
dmsbyrow <- function(x, long, lat){
# test for DMS format if not supplied
suppressWarnings(
dms <- is.na( as.numeric(x[,long]) == as.numeric(parzer::parse_lon(x[,long])) ))
# convert dms to dd, or rename input columns to dd#
if(dms == T){
x$latitude_dd = parzer::parse_lat(x[,lat])
x$longitude_dd = parzer::parse_lon(x[,long])
x <- x[, -which(names(x) %in% c(lat, long))]
} else{
colnames(x)[which(names(x) == lat)] <- 'latitude_dd'
colnames(x)[which(names(x) == long)] <- 'longitude_dd'
}
return(x)
}
x <- lapply(x_spl, dmsbyrow, long = long, lat = lat) |>
data.table::rbindlist(use.names = TRUE)
x$latitude_dd <- as.numeric(x$latitude_dd)
x$longitude_dd <- as.numeric(x$longitude_dd)
# ensure the DD signs are appropriate for domain
x$latitude_dd <- round(abs(x$latitude_dd), 5)
x$longitude_dd <- round(abs(x$longitude_dd) * -1, 5)
# now overwrite the original DMS values in our exact format
x$latitude_dms = paste0(
'N ', format_degree(parzer::pz_degree(x$latitude_dd)),
round(parzer::pz_minute(x$latitude_dd), 2),
"'", round(parzer::pz_second(x$latitude_dd), 0)
)
x$longitude_dms = paste0(
'W ', format_degree(parzer::pz_degree(x$longitude_dd)),
round(parzer::pz_minute(x$longitude_dd), 2),
"'", round(parzer::pz_second(x$longitude_dd), 0)
)
x$longitude_dms <- gsub('-', "", x$longitude_dms)
return(x)
}
data <- dms2dd(data)
data <- bind_rows(ca)
data <- dms2dd(data)
View(ca)
# determine whether these data have already been processed by the script, using
# a unique combination of collection name and collection code.
processed <- read_sheet('1iOQBNeGqRJ3yhA-Sujas3xZ2Aw5rFkktUKv3N_e4o8M',
sheet = 'Processed California - 2024') %>%
select(Collection_number, Primary_Collector) %>%
mutate(UNIQUEID = paste0(Primary_Collector, Collection_number))
View(processed)
data <- dms2dd(data)
data <- bind_rows(ca)
data <- dms2dd(data)
View(data)
#' @returns dataframe(/tibble) with coordinates unambiguously labeled as being in both degress, minutes, seconds (_dms) and decimal degrees (_dd).
#' @examples
#'  coords <- data.frame(
#'   longitude_dd = runif(15, min = -120, max = -100),
#'   latitude_dd = runif(15, min = 35, max = 48)
#' )
#' coords_formatted <- dms2dd( coords )
#' head(coords_formatted)
#' colnames(coords_formatted)
#' @export
dms2dd <- function(x, lat, long, dms){
# identify columns if they were not supplied
if(missing(lat)){
lat = colnames(x)[grep('lat', colnames(x), ignore.case = T)] }
if(missing(long)){
long = colnames(x)[grep('long', colnames(x), ignore.case = T)] }
# remove any N | E | S | W, or for that matter other alphabetical characters
x[,long] <- gsub('[[:alpha:]]|\\s', "", x[,long])
x[,lat] <- gsub('[[:alpha:]]|\\s', "", x[,lat])
# we will need to perform this operation across every single row,
# because some people will put dms and dd in the same column...
x_spl <- split(x, f = 1:nrow(x))
dmsbyrow <- function(x, long, lat){
# test for DMS format if not supplied
suppressWarnings(
dms <- is.na( as.numeric(x[,long]) == as.numeric(parzer::parse_lon(x[,long])) ))
# convert dms to dd, or rename input columns to dd#
if(dms == T){
x$latitude_dd = parzer::parse_lat(x[,lat])
x$longitude_dd = parzer::parse_lon(x[,long])
x <- x[, -which(names(x) %in% c(lat, long))]
} else{
colnames(x)[which(names(x) == lat)] <- 'latitude_dd'
colnames(x)[which(names(x) == long)] <- 'longitude_dd'
}
return(x)
}
x <- lapply(x_spl, dmsbyrow, long = long, lat = lat) |>
data.table::rbindlist(use.names = TRUE)
x$latitude_dd <- as.numeric(x$latitude_dd)
x$longitude_dd <- as.numeric(x$longitude_dd)
# ensure the DD signs are appropriate for domain
x$latitude_dd <- round(abs(x$latitude_dd), 5)
x$longitude_dd <- round(abs(x$longitude_dd) * -1, 5)
# now overwrite the original DMS values in our exact format
x$latitude_dms = paste0(
'N ', format_degree(parzer::pz_degree(x$latitude_dd)),
round(parzer::pz_minute(x$latitude_dd), 2),
"'", round(parzer::pz_second(x$latitude_dd), 0)
)
x$longitude_dms = paste0(
'W ', format_degree(parzer::pz_degree(x$longitude_dd)),
round(parzer::pz_minute(x$longitude_dd), 2),
"'", round(parzer::pz_second(x$longitude_dd), 0)
)
x$longitude_dms <- gsub('-', "", x$longitude_dms)
return(x)
}
#' @returns dataframe(/tibble) with coordinates unambiguously labeled as being in both degress, minutes, seconds (_dms) and decimal degrees (_dd).
#' @examples
#'  coords <- data.frame(
#'   longitude_dd = runif(15, min = -120, max = -100),
#'   latitude_dd = runif(15, min = 35, max = 48)
#' )
#' coords_formatted <- dms2dd( coords )
#' head(coords_formatted)
#' colnames(coords_formatted)
#' @export
dms2dd <- function(x, lat, long, dms){
# identify columns if they were not supplied
if(missing(lat)){
lat = colnames(x)[grep('lat', colnames(x), ignore.case = T)] }
if(missing(long)){
long = colnames(x)[grep('long', colnames(x), ignore.case = T)] }
# remove any N | E | S | W, or for that matter other alphabetical characters
x[,long] <- gsub('[[:alpha:]]|\\s', "", x[,long])
x[,lat] <- gsub('[[:alpha:]]|\\s', "", x[,lat])
# we will need to perform this operation across every single row,
# because some people will put dms and dd in the same column...
x_spl <- split(x, f = 1:nrow(x))
dmsbyrow <- function(x, long, lat){
# test for DMS format if not supplied
suppressWarnings(
dms <- is.na( as.numeric(x[,long]) == as.numeric(parzer::parse_lon(x[,long])) ))
# convert dms to dd, or rename input columns to dd#
if(dms == T){
x$latitude_dd = parzer::parse_lat(x[,lat])
x$longitude_dd = parzer::parse_lon(x[,long])
x <- x[, -which(names(x) %in% c(lat, long))]
} else{
colnames(x)[which(names(x) == lat)] <- 'latitude_dd'
colnames(x)[which(names(x) == long)] <- 'longitude_dd'
}
return(x)
}
x <- lapply(x_spl, dmsbyrow, long = long, lat = lat) |>
data.table::rbindlist(use.names = TRUE)
x$latitude_dd <- as.numeric(x$latitude_dd)
x$longitude_dd <- as.numeric(x$longitude_dd)
# ensure the DD signs are appropriate for domain
x$latitude_dd <- round(abs(x$latitude_dd), 5)
x$longitude_dd <- round(abs(x$longitude_dd) * -1, 7)
# now overwrite the original DMS values in our exact format
x$latitude_dms = paste0(
'N ', format_degree(parzer::pz_degree(x$latitude_dd)),
round(parzer::pz_minute(x$latitude_dd), 2),
"'", round(parzer::pz_second(x$latitude_dd), 0)
)
x$longitude_dms = paste0(
'W ', format_degree(parzer::pz_degree(x$longitude_dd)),
round(parzer::pz_minute(x$longitude_dd), 2),
"'", round(parzer::pz_second(x$longitude_dd), 0)
)
x$longitude_dms <- gsub('-', "", x$longitude_dms)
return(x)
}
data <- bind_rows(ca)
data <- dms2dd(data)
View(data)
ca <- read_sheet('1iOQBNeGqRJ3yhA-Sujas3xZ2Aw5rFkktUKv3N_e4o8M',
sheet = 'Data Entry California - 2024') %>%
mutate(UNIQUEID = paste0(Primary_Collector, Collection_number)) %>%
data.frame()
data <- bind_rows(ca)
View(data)
data1 <- dms2dd(data)
View(data1)
#' @returns dataframe(/tibble) with coordinates unambiguously labeled as being in both degress, minutes, seconds (_dms) and decimal degrees (_dd).
#' @examples
#'  coords <- data.frame(
#'   longitude_dd = runif(15, min = -120, max = -100),
#'   latitude_dd = runif(15, min = 35, max = 48)
#' )
#' coords_formatted <- dms2dd( coords )
#' head(coords_formatted)
#' colnames(coords_formatted)
#' @export
dms2dd <- function(x, lat, long, dms){
# identify columns if they were not supplied
if(missing(lat)){
lat = colnames(x)[grep('lat', colnames(x), ignore.case = T)] }
if(missing(long)){
long = colnames(x)[grep('long', colnames(x), ignore.case = T)] }
# remove any N | E | S | W, or for that matter other alphabetical characters
x[,long] <- gsub('[[:alpha:]]|\\s', "", x[,long])
x[,lat] <- gsub('[[:alpha:]]|\\s', "", x[,lat])
# we will need to perform this operation across every single row,
# because some people will put dms and dd in the same column...
x_spl <- split(x, f = 1:nrow(x))
dmsbyrow <- function(x, long, lat){
# test for DMS format if not supplied
suppressWarnings(
dms <- is.na( as.numeric(x[,long]) == as.numeric(parzer::parse_lon(x[,long])) ))
# convert dms to dd, or rename input columns to dd#
if(dms == T){
x$latitude_dd = parzer::parse_lat(x[,lat])
x$longitude_dd = parzer::parse_lon(x[,long])
x <- x[, -which(names(x) %in% c(lat, long))]
} else{
colnames(x)[which(names(x) == lat)] <- 'latitude_dd'
colnames(x)[which(names(x) == long)] <- 'longitude_dd'
}
return(x)
}
x <- lapply(x_spl, dmsbyrow, long = long, lat = lat) |>
data.table::rbindlist(use.names = TRUE)
x$latitude_dd <- as.numeric(x$latitude_dd)
x$longitude_dd <- as.numeric(x$longitude_dd)
return(x$longitude_dd)
# ensure the DD signs are appropriate for domain
x$latitude_dd <- round(abs(x$latitude_dd), 5)
x$longitude_dd <- round(abs(x$longitude_dd) * -1, 7)
# now overwrite the original DMS values in our exact format
x$latitude_dms = paste0(
'N ', format_degree(parzer::pz_degree(x$latitude_dd)),
round(parzer::pz_minute(x$latitude_dd), 2),
"'", round(parzer::pz_second(x$latitude_dd), 0)
)
x$longitude_dms = paste0(
'W ', format_degree(parzer::pz_degree(x$longitude_dd)),
round(parzer::pz_minute(x$longitude_dd), 2),
"'", round(parzer::pz_second(x$longitude_dd), 0)
)
x$longitude_dms <- gsub('-', "", x$longitude_dms)
return(x)
}
data1 <- dms2dd(data)
data1
#' @returns dataframe(/tibble) with coordinates unambiguously labeled as being in both degress, minutes, seconds (_dms) and decimal degrees (_dd).
#' @examples
#'  coords <- data.frame(
#'   longitude_dd = runif(15, min = -120, max = -100),
#'   latitude_dd = runif(15, min = 35, max = 48)
#' )
#' coords_formatted <- dms2dd( coords )
#' head(coords_formatted)
#' colnames(coords_formatted)
#' @export
dms2dd <- function(x, lat, long, dms){
# identify columns if they were not supplied
if(missing(lat)){
lat = colnames(x)[grep('lat', colnames(x), ignore.case = T)] }
if(missing(long)){
long = colnames(x)[grep('long', colnames(x), ignore.case = T)] }
# remove any N | E | S | W, or for that matter other alphabetical characters
x[,long] <- gsub('[[:alpha:]]|\\s', "", x[,long])
x[,lat] <- gsub('[[:alpha:]]|\\s', "", x[,lat])
# we will need to perform this operation across every single row,
# because some people will put dms and dd in the same column...
x_spl <- split(x, f = 1:nrow(x))
dmsbyrow <- function(x, long, lat){
# test for DMS format if not supplied
suppressWarnings(
dms <- is.na( as.numeric(x[,long]) == as.numeric(parzer::parse_lon(x[,long])) ))
# convert dms to dd, or rename input columns to dd#
if(dms == T){
x$latitude_dd = parzer::parse_lat(x[,lat])
x$longitude_dd = parzer::parse_lon(x[,long])
x <- x[, -which(names(x) %in% c(lat, long))]
} else{
colnames(x)[which(names(x) == lat)] <- 'latitude_dd'
colnames(x)[which(names(x) == long)] <- 'longitude_dd'
}
return(x)
}
x <- lapply(x_spl, dmsbyrow, long = long, lat = lat) |>
data.table::rbindlist(use.names = TRUE)
return(x$longitude_dd)
x$latitude_dd <- as.numeric(x$latitude_dd)
x$longitude_dd <- as.numeric(x$longitude_dd)
# ensure the DD signs are appropriate for domain
x$latitude_dd <- round(abs(x$latitude_dd), 5)
x$longitude_dd <- round(abs(x$longitude_dd) * -1, 7)
# now overwrite the original DMS values in our exact format
x$latitude_dms = paste0(
'N ', format_degree(parzer::pz_degree(x$latitude_dd)),
round(parzer::pz_minute(x$latitude_dd), 2),
"'", round(parzer::pz_second(x$latitude_dd), 0)
)
x$longitude_dms = paste0(
'W ', format_degree(parzer::pz_degree(x$longitude_dd)),
round(parzer::pz_minute(x$longitude_dd), 2),
"'", round(parzer::pz_second(x$longitude_dd), 0)
)
x$longitude_dms <- gsub('-', "", x$longitude_dms)
return(x)
}
data1 <- dms2dd(data)
data1
#' @returns dataframe(/tibble) with coordinates unambiguously labeled as being in both degress, minutes, seconds (_dms) and decimal degrees (_dd).
#' @examples
#'  coords <- data.frame(
#'   longitude_dd = runif(15, min = -120, max = -100),
#'   latitude_dd = runif(15, min = 35, max = 48)
#' )
#' coords_formatted <- dms2dd( coords )
#' head(coords_formatted)
#' colnames(coords_formatted)
#' @export
dms2dd <- function(x, lat, long, dms){
# identify columns if they were not supplied
if(missing(lat)){
lat = colnames(x)[grep('lat', colnames(x), ignore.case = T)] }
if(missing(long)){
long = colnames(x)[grep('long', colnames(x), ignore.case = T)] }
# remove any N | E | S | W, or for that matter other alphabetical characters
x[,long] <- gsub('[[:alpha:]]|\\s', "", x[,long])
x[,lat] <- gsub('[[:alpha:]]|\\s', "", x[,lat])
# we will need to perform this operation across every single row,
# because some people will put dms and dd in the same column...
x_spl <- split(x, f = 1:nrow(x))
dmsbyrow <- function(x, long, lat){
# test for DMS format if not supplied
suppressWarnings(
dms <- is.na( as.numeric(x[,long]) == as.numeric(parzer::parse_lon(x[,long])) ))
# convert dms to dd, or rename input columns to dd#
if(dms == T){
x$latitude_dd = parzer::parse_lat(x[,lat])
x$longitude_dd = parzer::parse_lon(x[,long])
x <- x[, -which(names(x) %in% c(lat, long))]
} else{
colnames(x)[which(names(x) == lat)] <- 'latitude_dd'
colnames(x)[which(names(x) == long)] <- 'longitude_dd'
}
return(x)
}
x <- lapply(x_spl, dmsbyrow, long = long, lat = lat) |>
data.table::rbindlist(use.names = TRUE)
x$latitude_dd <- as.numeric(x$latitude_dd)
x$longitude_dd <- as.numeric(x$longitude_dd)
return(x$longitude_dd)
# ensure the DD signs are appropriate for domain
x$latitude_dd <- round(abs(x$latitude_dd), 5)
x$longitude_dd <- round(abs(x$longitude_dd) * -1, 7)
# now overwrite the original DMS values in our exact format
x$latitude_dms = paste0(
'N ', format_degree(parzer::pz_degree(x$latitude_dd)),
round(parzer::pz_minute(x$latitude_dd), 2),
"'", round(parzer::pz_second(x$latitude_dd), 0)
)
x$longitude_dms = paste0(
'W ', format_degree(parzer::pz_degree(x$longitude_dd)),
round(parzer::pz_minute(x$longitude_dd), 2),
"'", round(parzer::pz_second(x$longitude_dd), 0)
)
x$longitude_dms <- gsub('-', "", x$longitude_dms)
return(x)
}
data1 <- dms2dd(data)
data1
View(data)
as.numeric('-114.848816385599')
as.numeric('-114.848816385599', options(digits = 9))
#' @returns dataframe(/tibble) with coordinates unambiguously labeled as being in both degress, minutes, seconds (_dms) and decimal degrees (_dd).
#' @examples
#'  coords <- data.frame(
#'   longitude_dd = runif(15, min = -120, max = -100),
#'   latitude_dd = runif(15, min = 35, max = 48)
#' )
#' coords_formatted <- dms2dd( coords )
#' head(coords_formatted)
#' colnames(coords_formatted)
#' @export
dms2dd <- function(x, lat, long, dms){
# identify columns if they were not supplied
if(missing(lat)){
lat = colnames(x)[grep('lat', colnames(x), ignore.case = T)] }
if(missing(long)){
long = colnames(x)[grep('long', colnames(x), ignore.case = T)] }
# remove any N | E | S | W, or for that matter other alphabetical characters
x[,long] <- gsub('[[:alpha:]]|\\s', "", x[,long])
x[,lat] <- gsub('[[:alpha:]]|\\s', "", x[,lat])
# we will need to perform this operation across every single row,
# because some people will put dms and dd in the same column...
x_spl <- split(x, f = 1:nrow(x))
dmsbyrow <- function(x, long, lat){
# test for DMS format if not supplied
suppressWarnings(
dms <- is.na( as.numeric(x[,long]) == as.numeric(parzer::parse_lon(x[,long])) ))
# convert dms to dd, or rename input columns to dd#
if(dms == T){
x$latitude_dd = parzer::parse_lat(x[,lat])
x$longitude_dd = parzer::parse_lon(x[,long])
x <- x[, -which(names(x) %in% c(lat, long))]
} else{
colnames(x)[which(names(x) == lat)] <- 'latitude_dd'
colnames(x)[which(names(x) == long)] <- 'longitude_dd'
}
return(x)
}
x <- lapply(x_spl, dmsbyrow, long = long, lat = lat) |>
data.table::rbindlist(use.names = TRUE)
x$latitude_dd <- as.numeric(x$latitude_dd, options(digits = 9))
x$longitude_dd <- as.numeric(x$longitude_dd, options(digits = 9))
# ensure the DD signs are appropriate for domain
x$latitude_dd <- round(abs(x$latitude_dd), 5)
x$longitude_dd <- round(abs(x$longitude_dd) * -1, 5)
# now overwrite the original DMS values in our exact format
x$latitude_dms = paste0(
'N ', format_degree(parzer::pz_degree(x$latitude_dd)),
round(parzer::pz_minute(x$latitude_dd), 2),
"'", round(parzer::pz_second(x$latitude_dd), 0)
)
x$longitude_dms = paste0(
'W ', format_degree(parzer::pz_degree(x$longitude_dd)),
round(parzer::pz_minute(x$longitude_dd), 2),
"'", round(parzer::pz_second(x$longitude_dd), 0)
)
x$longitude_dms <- gsub('-', "", x$longitude_dms)
return(x)
}
data1 <- dms2dd(data)
View(data1)
devtools::install_github('sagesteppe/BarnebyLives')
